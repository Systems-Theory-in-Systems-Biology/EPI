<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>epi.core package &mdash; EPI  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="epi.plotting package" href="epi.plotting.html" />
    <link rel="prev" title="epi package" href="epi.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            EPI
              <img src="_static/epi.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">API DOC</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="epi.html">epi package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="epi.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">epi.core package</a></li>
<li class="toctree-l4"><a class="reference internal" href="epi.plotting.html">epi.plotting package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="epi.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="epi.html#module-epi.jax_extension">epi.jax_extension module</a></li>
<li class="toctree-l3"><a class="reference internal" href="epi.html#module-epi">Module contents</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tests.html">tests package</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_material/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="MarkdownLinks/development.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="MarkdownLinks/contributing.html">Contributing to EPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="MarkdownLinks/license.html">LICENSE</a></li>
<li class="toctree-l1"><a class="reference internal" href="MarkdownLinks/citation.html">Citation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">EPI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">EPI</a></li>
          <li class="breadcrumb-item"><a href="epi.html">epi package</a></li>
      <li class="breadcrumb-item active">epi.core package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/epi.core.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="epi-core-package">
<h1>epi.core package<a class="headerlink" href="#epi-core-package" title="Permalink to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this heading"></a></h2>
</section>
<section id="module-epi.core.functions">
<span id="epi-core-functions-module"></span><h2>epi.core.functions module<a class="headerlink" href="#module-epi.core.functions" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="epi.core.functions.calcGramDeterminant">
<span class="sig-prename descclassname"><span class="pre">epi.core.functions.</span></span><span class="sig-name descname"><span class="pre">calcGramDeterminant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">jac</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#epi.core.functions.calcGramDeterminant" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the pseudo-determinant of the jacobian (that serves as a correction term) in one specific parameter point.
Returns 0 if the correction factor is not finite.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>jac</strong> (<em>jnp.ndarray</em>) – The jacobian for which the pseudo determinant shall be calculated</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.functions.evalLogTransformedDensity">
<span class="sig-prename descclassname"><span class="pre">epi.core.functions.</span></span><span class="sig-name descname"><span class="pre">evalLogTransformedDensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataStdevs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#epi.core.functions.evalLogTransformedDensity" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Given a simulation model, its derivative and corresponding data, evaluate the natural log of the parameter density that is the backtransformed data distribution.</dt><dd><p>This function is intended to be used with the emcee sampler and can be implemented more efficiently at some points.</p>
</dd>
<dt>Input: param (parameter for which the transformed density shall be evaluated)</dt><dd><p>model
data (data for the model: 2D array with shape (#numDataPoints, #dataDim))
dataStdevs (array of suitable kernel standard deviations for each data dimension)</p>
</dd>
<dt>Output: logTransformedDensity (natural log of parameter density at the point param)</dt><dd><p>: allRes (array concatenation of parameters, simulation results and evaluated density, stored as “blob” by the emcee sampler)</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-epi.core.kde">
<span id="epi-core-kde-module"></span><h2>epi.core.kde module<a class="headerlink" href="#module-epi.core.kde" title="Permalink to this heading"></a></h2>
<p>This module provides functions to handle the Kernel Densitiy Estimation (<a class="reference external" href="https://en.wikipedia.org/wiki/Kernel_density_estimation">KDE</a>) in EPI.</p>
<dl class="py function">
<dt class="sig sig-object py" id="epi.core.kde.calcKernelWidth">
<span class="sig-prename descclassname"><span class="pre">epi.core.kde.</span></span><span class="sig-name descname"><span class="pre">calcKernelWidth</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#epi.core.kde.calcKernelWidth" title="Permalink to this definition"></a></dt>
<dd><p>Sets the width of the kernels used for density estimation of the data according to the Silverman rule</p>
<p>Input: data: 2d array with shape (#Samples, #MeasurementDimensions): data for the model</p>
<p>Output: stdevs: array with shape (#MeasurementDimensions): suitable kernel standard deviations for each measurement dimension</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.kde.evalKDECauchy">
<span class="sig-prename descclassname"><span class="pre">epi.core.kde.</span></span><span class="sig-name descname"><span class="pre">evalKDECauchy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simRes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scales</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#epi.core.kde.evalKDECauchy" title="Permalink to this definition"></a></dt>
<dd><dl>
<dt>Evaluates a Cauchy Kernel Density estimator in one or several simulation results.</dt><dd><p>Assumes that each data point is a potentially high-dimensional sample
from a joint data distribution.
This is for example given for time-series data, where each evaluation
time is one dimension of the data point.
In the following formula x are the evaluation points (simRes) and y is the data.</p>
<div class="math notranslate nohighlight">
\[density_{i} = \frac{1}{samples} \sum_{s=1}^{samples} \prod_{d=1}^{dims} \frac{1}{(\frac{x_{i,d} - y_{s,d}}{scales_d})^2 \; \pi \; scales_d}\]</div>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>jnp.ndarray</em>) – data for the model: 2D array with shape (#Samples, #MeasurementDimensions)</p></li>
<li><p><strong>simRes</strong> (<em>jnp.ndarray</em>) – evaluation coordinates array of shape (#nEvals, #MeasurementDimensions) or (#MeasurementDimensions,)</p></li>
<li><p><strong>scales</strong> (<em>jnp.ndarray</em>) – one scale for each dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>estimated kernel density evaluated at the simulation result(s), shape: (#nEvals,) or ()</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.double</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.kde.evalKDEGauss">
<span class="sig-prename descclassname"><span class="pre">epi.core.kde.</span></span><span class="sig-name descname"><span class="pre">evalKDEGauss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simRes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scales</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Array</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float64</span></span></span><a class="headerlink" href="#epi.core.kde.evalKDEGauss" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates a Gaussian Kernel Density estimator in one or severalsimulation result.
Assumes that each data point is a potentially high-dimensional sample from a joint data distribution.
This is for example given for time-series data, where each evaluation time is one dimension of the data point.
While it is possible to define different standard deviations for different measurement dimensions, it is so far not possible to define covariances.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>jnp.ndarray</em>) – data for the model: 2D array with shape (#Samples, #MeasurementDimensions)</p></li>
<li><p><strong>simRes</strong> (<em>jnp.ndarray</em>) – evaluation coordinates array of shape (#nEvals, #MeasurementDimensions) or (#MeasurementDimensions,)</p></li>
<li><p><strong>scales</strong> (<em>jnp.ndarray</em>) – one scale for each dimension</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>estimated kernel density evaluated at the simulation result(s), shape: (#nEvals,) or ()</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>jnp.double</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-epi.core.model">
<span id="epi-core-model-module"></span><h2>epi.core.model module<a class="headerlink" href="#module-epi.core.model" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="epi.core.model.ArtificialModelInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.model.</span></span><span class="sig-name descname"><span class="pre">ArtificialModelInterface</span></span><a class="headerlink" href="#epi.core.model.ArtificialModelInterface" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>By inheriting from this interface you indicate that you are providing an artificial parameter dataset,
and the corresponding artificial data dataset, which can be used to compare the results from epi with the ground truth.
The comparison can be done using the plotEmceeResults.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Implement the generateArtificialData function to implement this interface.</p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="epi.core.model.ArtificialModelInterface.NUM_ARTIFICIAL_SAMPLES">
<span class="sig-name descname"><span class="pre">NUM_ARTIFICIAL_SAMPLES</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1000</span></em><a class="headerlink" href="#epi.core.model.ArtificialModelInterface.NUM_ARTIFICIAL_SAMPLES" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.ArtificialModelInterface.generateArtificialData">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generateArtificialData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numSamples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#epi.core.model.ArtificialModelInterface.generateArtificialData" title="Permalink to this definition"></a></dt>
<dd><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method returns None. You have to do the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">trueParams</span><span class="p">,</span>
    <span class="s2">&quot;Data/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getModelName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;Params.csv&quot;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span>
<span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">trueData</span><span class="p">,</span>
    <span class="s2">&quot;Data/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">getModelName</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;Data.csv&quot;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>To create the true data from the true params, you can simply call your model.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Generating the artificial data is up to the user</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.ArtificialModelInterface.paramLoader">
<span class="sig-name descname"><span class="pre">paramLoader</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#epi.core.model.ArtificialModelInterface.paramLoader" title="Permalink to this definition"></a></dt>
<dd><p>Load and return all parameters for artificial set ups</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Loaded parameters and the optimal kernel width for each parameter</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>Tuple[np.ndarray, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="epi.core.model.JaxModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.model.</span></span><span class="sig-name descname"><span class="pre">JaxModel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.JaxModel" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><code class="xref py py-class docutils literal notranslate"><span class="pre">Model</span></code></a></p>
<p>The JaxModel class automatically creates the jacobian method based on the forward method.
Additionally it jit compiles the forward and jacobian method with jax.
To use this class you have to implement your forward method using jax, e. g. jax.numpy.
Dont overwrite the __init__ method of JaxModel without calling the super constructor.
Else your forward method wont be jitted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Model</strong> (<a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><em>Model</em></a>) – Abstract parent class</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.JaxModel.forward_method">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward_method</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.JaxModel.forward_method" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.JaxModel.initFwAndBw">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">initFwAndBw</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.JaxModel.initFwAndBw" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.JaxModel.jacobian">
<span class="sig-name descname"><span class="pre">jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.JaxModel.jacobian" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the jacobian of the <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param</strong> (<em>np.ndarray</em>) – The parameter(set) for which the jacobian of your model should be evaluated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The jacobian for the variables returned by the <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> method with respect to the parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.JaxModel.valjac">
<span class="sig-name descname"><span class="pre">valjac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.JaxModel.valjac" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the jacobian and the forward pass of the model at the same time. If the method is not overwritten in a subclass it,
it simply calls <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param</strong> (<em>np.ndarray</em>) – The parameter(set) for which the model and the jacobian should be evaluated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="epi.core.model.Model">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.model.</span></span><span class="sig-name descname"><span class="pre">Model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">delete</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">create</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>The base class for all models using the EPI algorithm.</p>
<p>It contains three abstract methods which need to be implemented by subclasses</p>
<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.createApplicationFolderStructure">
<span class="sig-name descname"><span class="pre">createApplicationFolderStructure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#epi.core.model.Model.createApplicationFolderStructure" title="Permalink to this definition"></a></dt>
<dd><p>Creates the <cite>Application</cite> folder including subfolder where all simulation results
are stored for this model. No files are deleted during this action.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="epi.core.model.Model.dataDim">
<span class="sig-name descname"><span class="pre">dataDim</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#epi.core.model.Model.dataDim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.dataLoader">
<span class="sig-name descname"><span class="pre">dataLoader</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#epi.core.model.Model.dataLoader" title="Permalink to this definition"></a></dt>
<dd><p>Load the data from the data file found under the models current data path and calculate several properties of the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The dimension of the data space, the data and the estimated optimal kernel width for each dimension of the data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.deleteApplicationFolderStructure">
<span class="sig-name descname"><span class="pre">deleteApplicationFolderStructure</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model.deleteApplicationFolderStructure" title="Permalink to this definition"></a></dt>
<dd><p>Deletes the models <cite>Applications</cite> subfolder</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.forward">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model.forward" title="Permalink to this definition"></a></dt>
<dd><p>Executed the forward pass of the model to obtain data from a parameter. You can also do equivalently <code class="code docutils literal notranslate"><span class="pre">model(param)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param</strong> – The parameter(set) for which the model should be evaluated.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>NotImplementedError</strong> – Implement this method to make you model callable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.getApplicationPath">
<span class="sig-name descname"><span class="pre">getApplicationPath</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#epi.core.model.Model.getApplicationPath" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path to the simulation results folder, containing also intermediate results</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>path as string to the simulation folder</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.getCentralParam">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getCentralParam</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.model.Model.getCentralParam" title="Permalink to this definition"></a></dt>
<dd><p>Define a model-specific central parameter point, which will be used as starting point for the mcmc sampler.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Implement this method to provide a good starting point for the mcmc sampler.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A single parameter point in the format np.array([p_dim1, p_dim2, …])</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.getModelName">
<span class="sig-name descname"><span class="pre">getModelName</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#epi.core.model.Model.getModelName" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the class to which the object belongs. Overwrite it if you want to
give your model a custom name, e. g. depending on the name of your parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The class name of the calling object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.getParamSamplingLimits">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getParamSamplingLimits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.model.Model.getParamSamplingLimits" title="Permalink to this definition"></a></dt>
<dd><p>Define model-specific lower and upper limits for the sampling
to avoid parameter regions where the evaluation of the model is instable.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>NotImplementedError</strong> – Implement this method allow the mcmc sampler to work stably</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The limits in the format np.array([lower_dim1, upper_dim1], [lower_dim2, upper_dim2], …)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.isArtificial">
<span class="sig-name descname"><span class="pre">isArtificial</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#epi.core.model.Model.isArtificial" title="Permalink to this definition"></a></dt>
<dd><p>Determines whether the model provides artificial data</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the model inherits from the ArtificialModelInterface</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.isVisualizable">
<span class="sig-name descname"><span class="pre">isVisualizable</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#epi.core.model.Model.isVisualizable" title="Permalink to this definition"></a></dt>
<dd><p>Determines whether the model provides bounds for the visualization grids</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if the model inherits from the VisualizationModelInterface</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.jacobian">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">jacobian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model.jacobian" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the jacobian of the <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param</strong> (<em>np.ndarray</em>) – The parameter(set) for which the jacobian of your model should be evaluated.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The jacobian for the variables returned by the <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> method with respect to the parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.loadSimResults">
<span class="sig-name descname"><span class="pre">loadSimResults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">numBurnSamples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occurrence</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model.loadSimResults" title="Permalink to this definition"></a></dt>
<dd><p>Load the files generated by the EPI algorithm through sampling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><em>Model</em></a>) – Model from which the results will be loaded</p></li>
<li><p><strong>numBurnSamples</strong> (<em>int</em>) – Ignore the first samples of each chain</p></li>
<li><p><strong>occurrence</strong> (<em>int</em>) – step of sampling from chains</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>_description_</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>_type_</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="epi.core.model.Model.paramDim">
<span class="sig-name descname"><span class="pre">paramDim</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#epi.core.model.Model.paramDim" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.setDataPath">
<span class="sig-name descname"><span class="pre">setDataPath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#epi.core.model.Model.setDataPath" title="Permalink to this definition"></a></dt>
<dd><p>Set the path to the data file which shall be used from now on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<em>str</em>) – The path to the data file.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.Model.valjac">
<span class="sig-name descname"><span class="pre">valjac</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.Model.valjac" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the jacobian and the forward pass of the model at the same time. If the method is not overwritten in a subclass it,
it simply calls <code class="xref py py-func docutils literal notranslate"><span class="pre">forward()</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">jacobian()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>param</strong> (<em>np.ndarray</em>) – The parameter(set) for which the model and the jacobian should be evaluated.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="epi.core.model.VisualizationModelInterface">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.model.</span></span><span class="sig-name descname"><span class="pre">VisualizationModelInterface</span></span><a class="headerlink" href="#epi.core.model.VisualizationModelInterface" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">ABC</span></code></p>
<p>Provides the function for the generation of the dataGrid and paramGrid for the visualization of the distributions.
It forces subclasses to implement the abstract methods  getParamBounds: and getDataBounds:.</p>
<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.VisualizationModelInterface.generateVisualizationGrid">
<span class="sig-name descname"><span class="pre">generateVisualizationGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#epi.core.model.VisualizationModelInterface.generateVisualizationGrid" title="Permalink to this definition"></a></dt>
<dd><p>This function creates a grid for the data as well as the parameters with a
constant number of points in each dimension. It saves the grids as csv files in the <cite>Plots/*grid.csv</cite>
in your Application folder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>resolution</strong> (<em>int</em>) – The number of grid points in each dimension</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The dataGrid and teh paramGrid.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Tuple[np.ndarray, np.ndarray]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.VisualizationModelInterface.getDataBounds">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getDataBounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.model.VisualizationModelInterface.getDataBounds" title="Permalink to this definition"></a></dt>
<dd><p>Returns the bounds on the data used to visualize the data distribution.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>np.array: An array of the form [[lowerLimit_dim1, upperLimit_dim1], [lowerLimit_dim2, upperLimit_dim2],…]</p>
</dd>
<dt>Raises:</dt><dd><p>NotImplementedError: If the method is not implemented in the subclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.VisualizationModelInterface.getParamBounds">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">getParamBounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.model.VisualizationModelInterface.getParamBounds" title="Permalink to this definition"></a></dt>
<dd><p>Returns the bounds on the parameters used to visualize the parameter distribution.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>np.array: An array of the form [[lowerLimit_dim1, upperLimit_dim1], [lowerLimit_dim2, upperLimit_dim2],…]</p>
</dd>
<dt>Raises:</dt><dd><p>NotImplementedError: If the method is not implemented in the subclass</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.model.VisualizationModelInterface.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.VisualizationModelInterface.scale" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.model.autodiff">
<span class="sig-prename descclassname"><span class="pre">epi.core.model.</span></span><span class="sig-name descname"><span class="pre">autodiff</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_cls</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.model.autodiff" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-epi.core.sampling">
<span id="epi-core-sampling-module"></span><h2>epi.core.sampling module<a class="headerlink" href="#module-epi.core.sampling" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sampling.calcWalkerAcceptance">
<span class="sig-prename descclassname"><span class="pre">epi.core.sampling.</span></span><span class="sig-name descname"><span class="pre">calcWalkerAcceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWalkers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numBurnSamples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sampling.calcWalkerAcceptance" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Calculate the acceptance ratio for each individual walker of the emcee chain.</dt><dd><p>This is especially important to find “zombie” walkers, that are never moving.</p>
</dd>
<dt>Input: model</dt><dd><p>numBurnSamples (integer number of ignored first samples of each chain)
numWalkers (integer number of emcee walkers) that were used for the emcee chain which is analyzed here</p>
</dd>
</dl>
<p>Output: acceptanceRatios (np.array of size numWalkers)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sampling.concatenateEmceeSamplingResults">
<span class="sig-prename descclassname"><span class="pre">epi.core.sampling.</span></span><span class="sig-name descname"><span class="pre">concatenateEmceeSamplingResults</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sampling.concatenateEmceeSamplingResults" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Concatenate many sub runs of the emcee sampler to create 3 large files for sampled parameters, corresponding simulation results and density evaluations.</dt><dd><p>These files are later used for result visualization.</p>
</dd>
</dl>
<p>Input: model
Output: &lt;none except for stored files&gt;</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sampling.countEmceeSubRuns">
<span class="sig-prename descclassname"><span class="pre">epi.core.sampling.</span></span><span class="sig-name descname"><span class="pre">countEmceeSubRuns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#epi.core.sampling.countEmceeSubRuns" title="Permalink to this definition"></a></dt>
<dd><p>This data organization function counts how many sub runs are saved for the specified scenario.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> – The model for which the files will be counted</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>numExistingFiles (number of completed sub runs of the emcee particle swarm sampler)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sampling.inference">
<span class="sig-prename descclassname"><span class="pre">epi.core.sampling.</span></span><span class="sig-name descname"><span class="pre">inference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataPath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numRuns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWalkers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numSteps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numProcesses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sampling.inference" title="Permalink to this definition"></a></dt>
<dd><p>Starts the parameter inference for the given model. If a data path is given, it is used to load the data for the model. Else, the default data path of the model is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><em>Model</em></a>) – The model describing the mapping from parameters to data.</p></li>
<li><p><strong>dataPath</strong> (<em>str</em><em>, </em><em>optional</em>) – path to the data relative to the current working directory.
If None, the default path defined in the Model class initializer is used, defaults to None</p></li>
<li><p><strong>numRuns</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of independent runs, defaults to NUM_RUNS</p></li>
<li><p><strong>numWalkers</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of walkers for each run, influencing each other, defaults to NUM_WALKERS</p></li>
<li><p><strong>numSteps</strong> (<em>int</em><em>, </em><em>optional</em>) – Number of steps each walker does in each run, defaults to NUM_STEPS</p></li>
<li><p><strong>numProcesses</strong> (<em>int</em><em>, </em><em>optional</em>) – number of processes to use, defaults to NUM_PROCESSES</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sampling.runEmceeSampling">
<span class="sig-prename descclassname"><span class="pre">epi.core.sampling.</span></span><span class="sig-name descname"><span class="pre">runEmceeSampling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">numRuns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numWalkers</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numSteps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numProcesses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#epi.core.sampling.runEmceeSampling" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Create a representative sample from the transformed parameter density using the emcee particle swarm sampler.</dt><dd><p>Inital values are not stored in the chain and each file contains &lt;numSteps&gt; blocks of size numWalkers.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – The model which will be sampled</p></li>
<li><p><strong>numRuns</strong> – (number of stored sub runs)</p></li>
<li><p><strong>numWalkers</strong> – (number of particles in the particle swarm sampler)</p></li>
<li><p><strong>numSteps</strong> – (number of samples each particle performs before storing the sub run)</p></li>
<li><p><strong>numProcesses</strong> – (number of parallel threads)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>None, except for stored files</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-epi.core.sparsegrid">
<span id="epi-core-sparsegrid-module"></span><h2>epi.core.sparsegrid module<a class="headerlink" href="#module-epi.core.sparsegrid" title="Permalink to this heading"></a></h2>
<dl class="simple">
<dt>This module provides functions to handle create Sparse Grids (<a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_grid">SGs</a>) and work with them.</dt><dd><p>All pure SG functions are defined on the unit hypercube $[0,1]^d$.</p>
</dd>
</dl>
<dl class="py class">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">SparseGrid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxLevelSum</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Each object of this class respresents a sparse grid.
In this implementation, a sparse grid is a list of Smolnyak-subspaces.
Each subspace is in principle a regular grid of a certain grid width but every second grid point is negelcted.</p>
<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.computeAllPoints">
<span class="sig-name descname"><span class="pre">computeAllPoints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.computeAllPoints" title="Permalink to this definition"></a></dt>
<dd><p>Collect all SG points in one array by iterating over all subspaces.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.computeCoefficients">
<span class="sig-name descname"><span class="pre">computeCoefficients</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.computeCoefficients" title="Permalink to this definition"></a></dt>
<dd><p>When using sparse grids for function interpolation (and quadrature),
this function computes the coefficients of all basis function of the whole sparse grid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.computeIndexList4TopDownSparseGridTraverse">
<span class="sig-name descname"><span class="pre">computeIndexList4TopDownSparseGridTraverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.computeIndexList4TopDownSparseGridTraverse" title="Permalink to this definition"></a></dt>
<dd><p>Create an ordering of subspaces where low-level subspaces come before high-level ones.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.computeIntegral">
<span class="sig-name descname"><span class="pre">computeIntegral</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.computeIntegral" title="Permalink to this definition"></a></dt>
<dd><p>Perform sparse grid integration over whole Sparse Grid using the computed coefficients (coeffs) and the volume of each basis function (basisFuncVol)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.computeNPoints">
<span class="sig-name descname"><span class="pre">computeNPoints</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.computeNPoints" title="Permalink to this definition"></a></dt>
<dd><p>Iterates over all subspaces of the sparse grid and accumulates the total number of gridpoints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.evalFunctionSG">
<span class="sig-name descname"><span class="pre">evalFunctionSG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.evalFunctionSG" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate the provided function for all subspaces of a sparse grid by using Subspace.evalFunction</p>
<p>Input: function (python function that can be evaluated in one sparse grid point)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.SparseGrid.refineSubspace">
<span class="sig-name descname"><span class="pre">refineSubspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">currentLevels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexRefinedLevel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#epi.core.sparsegrid.SparseGrid.refineSubspace" title="Permalink to this definition"></a></dt>
<dd><p>Recursive function used to accumulate all subspaces up to a specified level sum in the form of a list
It returns the list itself together with a dictionary that maps the level-combination of each subspace onto its index inside the list.
This function only lists each subspace once.</p>
<dl class="simple">
<dt>Input: currentLevels (np.1darray of type int and shape #Dims that specifies the subspace we are currently considering)</dt><dd><p>indexRefinedLevel (int that stores the index that got altered to form the current subspace)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="epi.core.sparsegrid.Subspace">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">Subspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.sparsegrid.SparseGrid" title="epi.core.sparsegrid.SparseGrid"><span class="pre">SparseGrid</span></a></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.Subspace" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Objects represent one Smolnyak-Subspace of a sparse grid and are only defined by a level for each dimension.</p>
<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.Subspace.evalFunction">
<span class="sig-name descname"><span class="pre">evalFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.Subspace.evalFunction" title="Permalink to this definition"></a></dt>
<dd><p>Evaluate a function in all points of the respective subspace.
This function is typically called by SparseGrid.evalFunctionSG.</p>
<p>Input: function (python function that can be evaluated in one sparse grid point)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="epi.core.sparsegrid.Subspace.passContributions2HigherLevels">
<span class="sig-name descname"><span class="pre">passContributions2HigherLevels</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.Subspace.passContributions2HigherLevels" title="Permalink to this definition"></a></dt>
<dd><p>During sparse grid interpolation, this function passes contributions to all subspaces with higher level.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sparsegrid.basis1D">
<span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">basis1D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points1D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre1D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">level</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.sparsegrid.basis1D" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Evaluate a 1D hat function in an array of doubles. The hat is centered around centre1D</dt><dd><p>and the hat’s level defines its support. The support shrinks exponentially with growing level and a level of 0 is equivalent with full support on [0,1].</p>
</dd>
<dt>Input: points1D (np.1darray of 1D evaluation coordinate doubles)</dt><dd><p>centre1D (np.double indicating the centre of the hat within the interval [0,1])
level (int specifying the size/extend/support of the hat function)</p>
</dd>
</dl>
<p>Output: (np.1darray (size equivalent to size of points1D) of hat function evaluations)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sparsegrid.basisnD">
<span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">basisnD</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centre</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.sparsegrid.basisnD" title="Permalink to this definition"></a></dt>
<dd><p>Use a tensor product to generalise the 1D basis function to arbitrarily high dimensions.</p>
<dl class="simple">
<dt>Input: points (np.2darray of shape #Points x #Dims indicating the basis evaluation coordinates in nD)</dt><dd><p>centre (np.1darray of shape #Dims defining the nD centre of an nD basis function)
levels (np.1darray of type int and shape #Dims defining one basis function level per dimension)</p>
</dd>
</dl>
<p>Output: basisEval (np.1darray of shape #Points returning one nD basis evaluation per specified evaluation point)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sparsegrid.meshgrid2Matrix">
<span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">meshgrid2Matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">meshgrid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span></span></span><a class="headerlink" href="#epi.core.sparsegrid.meshgrid2Matrix" title="Permalink to this definition"></a></dt>
<dd><p>Convert a np.meshgrid into a np.2darray of grid points.
The function is mainly used when assigning grid points to Smolnyak-Subspaces.</p>
<p>Input: meshgrid (list of np.arrays returned by np.meshgrid)</p>
<p>Output: matrix (np.2darray of shape #Points x #Dims defining all grid points)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="epi.core.sparsegrid.sparseGridInference">
<span class="sig-prename descclassname"><span class="pre">epi.core.sparsegrid.</span></span><span class="sig-name descname"><span class="pre">sparseGridInference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><span class="pre">Model</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataPath</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numLevels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numProcesses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#epi.core.sparsegrid.sparseGridInference" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the transformed parameter density over a set of points resembling a sparse grid, thereby attempting parameter inference. If a data path is given, it is used to load the data for the model. Else, the default data path of the model is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference internal" href="#epi.core.model.Model" title="epi.core.model.Model"><em>Model</em></a>) – The model describing the mapping from parameters to data.</p></li>
<li><p><strong>dataPath</strong> (<em>str</em><em>, </em><em>optional</em>) – path to the data relative to the current working directory.
If None, the default path defined in the Model class initializer is used, defaults to None</p></li>
<li><p><strong>numLevels</strong> (<em>int</em><em>, </em><em>optional</em>) – Maximum sparse grid level depth that mainly defines the number of points, defaults to NUM_LEVELS</p></li>
<li><p><strong>numProcesses</strong> (<em>int</em><em>, </em><em>optional</em>) – number of processes to use, defaults to NUM_PROCESSES</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-epi.core">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-epi.core" title="Permalink to this heading"></a></h2>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="epi.html" class="btn btn-neutral float-left" title="epi package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="epi.plotting.html" class="btn btn-neutral float-right" title="epi.plotting package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022-2023, Vincent Wagner, Sebastian Höpfl, Lars Kaiser.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>